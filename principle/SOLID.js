Итог (коротко)
1) S - Single Responsibility Principle - принцип единственной ответственности.
Каждый класс должен иметь только одну зону ответственности.

2) O - Open closed Principle - принцип открытости-закрытости.
Классы должны быть открыты для расширения, но закрыты для изменения.

3) L - Liskov substitution Principle - принцип подстановки.
Должна быть возможность вместо базового (родительского) типа (класса) подставить
любой его подтип (класс-наследник), при этом работа программы не должна измениться.

4) I -  Interface Segregation Principle - принцип разделения интерфейсов.
Не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.

5) D - Dependency Inversion Principle - принцип инверсии зависимостей.
Модули верхнего уровня не должны зависеть от модулей нижнего уровня.
И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.


/*
1) single responsibility - Принцип единой ответственности (про декомпозицию)
1 класс - одна задача - единая зона ответственности
    - много связанного кода может ломать все при проломке чего-то
    - читабельность
    - вносить изменения должго и сложно
 */


/*
2) open-close - Принцип открытости-закрытости
Сущности (классы, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения
Изменять работающий протестированный код плохо, т.к. если его изменяем, нужно снова тестировать.

Т.е. желательно не изменять текущую сущность, а добавить новую посредством наследования, композиции
и реализовывать новый функционал уже там
    Профиты:
    - Нет необходимоти делать регрессионное тестирование (т.е. проверять код, что ничего не сломали)
    - Меньше вероятность ошибок
 */

/*
3) Liskov substitution - принцип подстановки Барбары Лисков
Функции, сущности, кот. использует родитель, должны точно так же работать и с дочерними классами
Наследуемый класс должен дополнять, а не замещать поведение базового класса

Т.е. все наследуемы классы должны уметь то, что умеет родитель.
 */


/*
4) Interface segregation - Принцип разделения интерфейса
Лучше разбивать толстые прогр. интерфейсы, сущности на маленькие, узкоспециализированные, решающие одну задачу
Нельзя заставлять клиента реализовывать интерфейс, кот. он не пользуется
    - избавляем сущности от методов, кот. они не используют
    - получаем более предсказуемую программу
    - код менее связанный
 */

/*
5) Dependency inversion - Принцип инверсии зависимости
Модули высокого уровня не должны зависеть от модулей низкого уровня,
все они должны зависеть от абстракций, а абстракции не должны зависеть от деталей
Детали должны зависеть от абстракций

Пример Завод - работники, станки (детали), электричество - при замене детали станков
если придется менять электричество или работников
Можно ввести новую сущность (трансформатор - для подбора напряжения, пульт управления - для работников, чтобы
могли работать уже с другими станками)

 */

